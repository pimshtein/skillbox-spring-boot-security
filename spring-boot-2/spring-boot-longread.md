# Лонгрид: Введение в Spring Boot

## 1. Зачем нужен Spring Boot?

### Проблемы классического Spring

Spring Framework — это очень мощный инструмент для создания корпоративных Java-приложений. Однако у классического Spring, как у всякого фреймворка, есть ряд особенностей, которые затрудняют быстрый старт и усложняют поддержку проектов:

- **Обилие конфигурации**: Для запуска даже простого приложения требовалось создавать множество XML-файлов или писать подробные Java-конфигурации. Это занимало много времени и увеличивало вероятность ошибок.
- **Ручная настройка инфраструктуры**: Необходимо было самостоятельно настраивать сервер приложений, подключать зависимости, регистрировать компоненты.
- **Повторяющийся шаблонный код**: Многие настройки и фрагменты кода приходилось копировать из проекта в проект.

**Пример:**
Чтобы запустить простое Spring MVC-приложение, нужно было:
- Создать web.xml
- Настроить DispatcherServlet
- Описать бины в XML или Java-конфигурации
- Подключить все зависимости вручную

## Вот пример web.xml для классического Spring MVC с минимальной конфигурацией:

```xml
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">

    <display-name>Spring MVC Application</display-name>

    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring/dispatcher-servlet.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>
```

Примерно та же картина была не только в мире Spring, но и в других Java фрейворках и технологиях. Пример из практики: фреймворк для работы с базой данных MyBatis, платформа для корпоративных приложений на Java, где также требовалась ручная настройка конфигураций.

---

### Как решает эти проблемы Spring Boot?

Spring Boot — это расширение Spring, которое автоматизирует и упрощает процесс создания приложений:
- **Автоматическая конфигурация**: Boot сам определяет, какие компоненты и настройки нужны, исходя из ваших зависимостей.
- **Встроенный сервер**: Не нужно отдельно устанавливать Tomcat или Jetty — сервер уже включён в приложение.
- **Быстрый запуск**: Приложение можно запустить одной командой, без дополнительных шагов по развертыванию.
- **Стартеры**: Готовые наборы зависимостей для типовых задач (web, JPA, security и др.), которые избавляют от необходимости вручную подбирать библиотеки.

**Вывод:**
Spring Boot позволяет сосредоточиться на бизнес-логике, а не на инфраструктуре и рутинной настройке.

---

## 2. Как работает Spring Boot?

### Автоконфигурация

Spring Boot анализирует ваши зависимости и автоматически подключает необходимые компоненты. Например, если вы добавили зависимость `spring-boot-starter-web`, Boot сам настроит веб-сервер, обработку HTTP-запросов, работу с JSON и т.д. Это позволяет минимизировать ручную настройку.

### Встроенные серверы


### Стартеры (Spring Boot Starters)

Стартер — это набор зависимостей для определённой задачи. Например:
- `spring-boot-starter-web` — для создания REST API и веб-приложений
- `spring-boot-starter-data-jpa` — для работы с базой данных через JPA
- `spring-boot-starter-security` — для добавления аутентификации и авторизации

**Преимущество:**
Вы просто добавляете нужный стартер — и получаете готовую инфраструктуру для своей задачи.

### Концепция и этапы работы Spring Boot

**Что такое Spring Boot концептуально?**

**Концептуально, Spring Boot — это "мнение" (opinion) о том, как лучше всего создавать приложения на Spring.** Он не заменяет Spring Framework, а является его расширением, которое предлагает готовые решения для типовых задач, основанные на лучших практиках.

**Физически, Spring Boot — это просто набор библиотек (JAR-файлов), которые вы добавляете в свой проект.** Ключевыми из них являются:
-   `spring-boot-starter-*`: Это "стартеры", которые не содержат кода, а просто описывают набор зависимостей для конкретной задачи (например, `spring-boot-starter-web` для веб-приложений).
-   `spring-boot-autoconfigure`: Это "сердце" Spring Boot. Библиотека содержит классы, которые автоматически настраивают ваше приложение на основе подключенных зависимостей.

Ключевая идея — **"соглашение вместо конфигурации" (convention over configuration)**. Вместо того чтобы вы вручную прописывали все настройки, Spring Boot предоставляет разумные конфигурации по умолчанию. Вы вмешиваетесь, только когда хотите изменить стандартное поведение.

**Как это работает по этапам?**

Когда вы запускаете Spring Boot-приложение, происходит примерно следующее:

1.  **Запуск (`main` метод с `SpringApplication.run`)**: Это точка входа. Вы нажимаете "старт".
2.  **Анализ зависимостей (Classpath Scanning)**: Spring Boot "сканирует" ваш проект и видит, какие стартеры вы подключили. Например, он находит `spring-boot-starter-web`.
3.  **Активация автоконфигурации**: На основе найденных стартеров, Boot активирует нужные классы автоконфигурации. Для `starter-web` это будут конфигурации для веб-сервера (Tomcat), обработки HTTP и т.д.
4.  **Создание "умных" бинов**: Автоконфигурация создаёт бины (объекты), но делает это "умно", с помощью аннотаций `@ConditionalOn...`. Например:
    - `@ConditionalOnClass(Tomcat.class)`: "Создать бин для Tomcat, только если в проекте есть класс Tomcat".
    - `@ConditionalOnMissingBean`: "Создать этот бин, только если пользователь не создал свой собственный такой же".
5.  **Сканирование ваших компонентов**: Boot находит ваши классы с аннотациями `@RestController`, `@Service`, `@Component` и добавляет их в контекст приложения.
6.  **Запуск приложения**: Наконец, Spring Boot запускает встроенный сервер (например, Tomcat) и разворачивает ваше приложение. Теперь оно готово принимать запросы.

Этот процесс позволяет вам запустить полнофункциональное веб-приложение, написав всего несколько строк кода.

Пример работы стартера для работы веб-приложений: вместо того чтобы отдельно устанавливать и настраивать сервер приложений, вы просто запускаете jar-файл — и сервер стартует вместе с вашим кодом. Это ускоряет разработку и упрощает деплой.

**Пример запуска сервера в Spring Boot (например, Tomcat):**

1. **Запуск приложения**
   - Вы запускаете приложение командой:
     ```bash
     ./gradlew bootRun
     ```
     или
     ```bash
     java -jar myapp.jar
     ```

2. **Выполнение метода main**
   - В вашем коде вызывается:
     ```java
     public static void main(String[] args) {
         SpringApplication.run(DemoApplication.class, args);
     }
     ```
   - Это точка входа для Spring Boot.

3. **Создание SpringApplication**
   - Класс `SpringApplication` анализирует ваш класс с аннотацией `@SpringBootApplication` и все зависимости на classpath.

4. **Анализ зависимостей и автоконфигурация**
   - Spring Boot видит, что у вас есть зависимость `spring-boot-starter-web`.
   - Это означает, что на classpath присутствует Tomcat (или Jetty/Undertow), Spring MVC и другие необходимые компоненты.

5. **Автоматическое создание и настройка сервера**
   - Благодаря автоконфигурации (`spring-boot-autoconfigure`), Spring Boot находит класс `TomcatServletWebServerFactory` (или аналогичный для Jetty/Undertow).
   - Создаётся бин этого класса, который отвечает за запуск встроенного сервера.

   ### Как выглядит автоконфигурация внутри spring-boot-autoconfigure?

В библиотеке `spring-boot-autoconfigure` содержатся специальные классы, которые автоматически настраивают компоненты приложения. Например, вот упрощённый и приблизительный пример автоконфигурации для Tomcat:

```java
@Configuration
public class TomcatWebServerFactoryAutoConfiguration {
    @Bean
    public TomcatServletWebServerFactory tomcatServletWebServerFactory() {
        return new TomcatServletWebServerFactory();
    }
}
```

- `@Configuration` и `@Bean` — стандартные аннотации Spring для конфигурации и создания бинов.

**Такие классы лежат внутри spring-boot-autoconfigure и автоматически подключаются, когда вы добавляете стартеры.**

6. **Создание ApplicationContext**
   - Spring Boot создаёт контекст приложения, сканирует ваши компоненты (`@RestController`, `@Service` и т.д.), регистрирует их как бины.

7. **Инициализация сервера**
   - Внутри автоконфигурации вызывается метод, который создаёт и настраивает экземпляр Tomcat (или другого сервера).
   - Сервер настраивается на порт по умолчанию (8080) или на тот, что указан в `application.properties`.

8. **Регистрация сервлетов и фильтров**
   - Все ваши контроллеры и фильтры автоматически регистрируются как сервлеты и фильтры в Tomcat.

9. **Запуск сервера**
   - Встроенный Tomcat запускается внутри того же процесса JVM, что и ваше приложение.
   - Сервер начинает слушать указанный порт и готов принимать HTTP-запросы.

10. **Готово!**
    - Вы видите в консоли сообщение вроде:
      ```
      Tomcat started on port(s): 8080 (http)
      Started DemoApplication in 2.345 seconds (JVM running for 2.789)
      ```
    - Теперь ваше приложение доступно по адресу http://localhost:8080 (или другому порту, которое указано в application.properties).

**Ключевой момент:**
Всё это происходит автоматически — вам не нужно вручную создавать или настраивать сервер, прописывать сервлеты в web.xml или деплоить приложение на внешний Tomcat. Всё управляется через автоконфигурацию Spring Boot и стартеры.

То есть все, что остается сделать программисту - это подключить стартер, сделать настройку (как правило, в application.yaml/application.properties файле) и запустить приложение.

Другие примеры стартеров:
- `spring-boot-starter-web` — для создания REST API и веб-приложений
- `spring-boot-starter-data-jpa` — для работы с базой данных через JPA
- `spring-boot-starter-security` — для добавления аутентификации и авторизации

---

## 3. Проблемы конфигурирования Spring (особенно Spring MVC)

До появления Spring Boot:
- Все настройки (view resolver, message converter, обработка статики и др.) приходилось прописывать вручную
- Ошибки в конфигурации часто приводили к долгому поиску проблемы
- Для разных окружений (разработка, тест, продакшн) требовались отдельные конфигурационные файлы

Spring Boot:
- Автоматически настраивает большинство параметров, но позволяет их переопределить при необходимости
- Поддерживает профили (`@Profile`, application-dev.properties, application-prod.properties), что удобно для разделения настроек по окружениям

---

## 4. Пример работы с профилями в Spring Boot

**Профили** позволяют удобно разделять настройки для разных окружений (разработка, тестирование, продакшн и т.д.). Это особенно полезно, если, например, на продакшене используется одна база данных, а на локальной машине — другая.

### Как это работает?

1. **Создайте разные файлы настроек:**
   - `application.properties` — общий конфиг для всех профилей
   - `application-dev.properties` — настройки для профиля "dev" (разработка)
   - `application-prod.properties` — настройки для профиля "prod" (продакшн)

2. **Пример содержимого файлов:**

`application.properties`:
```
spring.application.name=MyApp
server.port=8080
```

`application-dev.properties`:
```
spring.datasource.url=jdbc:h2:mem:testdb
logging.level.root=DEBUG
```

`application-prod.properties`:
```
spring.datasource.url=jdbc:postgresql://prod-server/mydb
logging.level.root=INFO
```

3. **Используйте аннотацию @Profile в коде (опционально):**

```java
@Service
@Profile("dev")
public class DevOnlyService {
    // Этот бин будет создан только если активен профиль dev
}
```

4. **Запускайте приложение с нужным профилем:**

- Через командную строку:
  ```bash
  java -jar myapp.jar --spring.profiles.active=dev
  ```
- Или через переменную окружения:
  ```bash
  export SPRING_PROFILES_ACTIVE=prod
  ./gradlew bootRun
  ```

5. **Spring Boot сам подхватит нужные настройки:**
   - Если активен профиль `dev`, будут применены настройки из `application.properties` и `application-dev.properties`.
   - Если активен профиль `prod`, будут применены настройки из `application.properties` и `application-prod.properties`.

6. ### Как Spring Boot реализует работу с профилями (технически)

- Spring Boot при запуске смотрит на параметр `spring.profiles.active` (его можно задать через командную строку, переменную окружения или в application.properties).
- В зависимости от активного профиля, он автоматически подгружает соответствующие файлы настроек (например, `application-dev.properties`).
- В коде можно использовать аннотацию `@Profile("dev")` — бин будет создан только если активен этот профиль.

**Короткий пример:**

`application.properties`:
```
spring.profiles.active=dev
```

`application-dev.properties`:
```
custom.message=Hello from DEV
```

`application-prod.properties`:
```
custom.message=Hello from PROD
```

```java
@Service
@Profile("dev")
public class DevOnlyService {
    // Этот бин будет создан только если активен профиль dev
}
```

**Если вы запустите приложение с профилем dev, будет использовано значение из application-dev.properties и создан бин DevOnlyService.**

**Итог:**
Профили позволяют легко переключаться между разными конфигурациями без изменения основного кода приложения. Это удобно и безопасно для командной разработки и деплоя.

---

## 6. Заключение

Spring Boot — это инструмент, который позволяет быстро и удобно создавать современные Java-приложения. Он избавляет от рутинной настройки, ускоряет разработку и делает проекты более поддерживаемыми. Благодаря Spring Boot вы можете сосредоточиться на решении бизнес-задач, а не на инфраструктуре.

---