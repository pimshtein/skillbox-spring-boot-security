# Структура и настройка Spring Security

## Введение

Spring Security — это фреймворк для обеспечения аутентификации, авторизации и других аспектов безопасности в приложениях на базе Spring. Он широко используется для защиты веб-приложений, REST API и микросервисов.

В этом уроке мы рассмотрим архитектуру Spring Security, основные компоненты, внутренние механизмы работы и подходы к настройке безопасности.
А также сделаем практический пример, где будет подробное базовое объяснение работы и настроек Spring Security для работы на боевых проектах.

---
Рассмотрим базовые аспекты Spring Security.

## 1. Архитектура

Spring Security реализует многоуровневую архитектуру, основанную на цепочке фильтров (Filter Chain). Каждый HTTP-запрос, поступающий в приложение, проходит через последовательность фильтров, где на каждом этапе выполняется определённая задача по обеспечению безопасности.

### 1.1. Цепочка фильтров (Security Filter Chain)

Центральное место занимает SecurityFilterChain — набор фильтров, через которые проходят все входящие запросы. Каждый фильтр отвечает за отдельный аспект безопасности: аутентификацию, авторизацию, защиту от CSRF, обработку сессий и т.д. Порядок фильтров строго определён и влияет на поведение системы.

### 1.2. Провайдеры аутентификации (Authentication Providers)

Аутентификация пользователя осуществляется через AuthenticationManager, который делегирует проверку учетных данных одному или нескольким AuthenticationProvider. Каждый провайдер реализует свой способ проверки: через базу данных, LDAP, OAuth2, JWT и др. 
Это позволяет довольно гибко настраивать способы входа в систему.

### 1.3. Механизм авторизации (Authorization)

После успешной аутентификации система определяет, имеет ли пользователь право на выполнение определённых действий. Для этого используются объекты GrantedAuthority (роли и привилегии), а также механизмы аннотаций (@PreAuthorize, @Secured) и конфигурация на уровне URL.

### 1.4. Работа с сессиями и состоянием

Spring Security поддерживает различные режимы работы с сессиями: создание, фиксация, ограничение количества одновременных сессий, автоматический выход при истечении времени.

### 1.5. Расширяемость и интеграция

Spring Security легко расширяется за счёт собственных фильтров, провайдеров, обработчиков событий. 
Он интегрируется с другими модулями Spring (Spring Data, Spring OAuth2, Spring Session) и сторонними сервисами (LDAP, OpenID, SAML, JWT).
Далее мы рассмотрим это на практическом примере.

---

## 2. Базовая конфигурация Spring Security

В современных версиях Spring Boot настройка безопасности осуществляется через Java-конфигурацию с помощью аннотаций и бинов. 
позволяет гибко управлять политиками доступа, способами аутентификации и дополнительными модулями безопасности.

---

Давайте теперь на практическом примере попробуем сконфигурировать Spring Security и посмотрим более детально, как это работает.
Представим, что у нас есть небольшая задача - вывести данные о пользователе в браузере.
Мы должны перейти по определенному адресу, нам предложат пройти аутентификацию, введем логин и пароль и на странице
отобразятся данные о пользователе.

[Видео]
Давайте вначале посмотрим на код, который я подготовил.
Затем запустим приложение и посмотрим вживую, как это работает.
И более подробно рассмотрим, как это всё работает в целом, начиная с запроса в браузере.
У нас в коде есть:
- CustomUserDetailsService - сервис, который "достает" пользователя из БД
- SecurityConfig - config для Spring, который описывает, как именно будет работать наша аутентификация/авторизация
- UserController - контроллер, в котором есть endpoint api/me - этот endpoint выводит информацию о пользователе.
- UserEntity - сущность для таблицы users в БД
- UserRepository - репозиторий для таблицы users. Через него мы будем получать пользователя, который пытается авторизоваться в системе
- resources/scripts.sql - скрипт sql для создания пользователя в БД. Обратите внимание, что пароль в таблице хранится не в чистом виде, а в зашифрованном виде с помощью алгоритма Bcrypt.
Этот алгоритм шифрования взят просто для примера, как один из распространенных алгоритмов.
- В таблице users у нас есть username, password и role (роль в системе, типа admfin, user, manager)


1. Делаем запрос на api/me в браузере. Пользователь пока неавторизован.
При этом:
- Пользователь пытается получить доступ к защищенному ресурсу
- Так как у нас подключен Spring Security и есть SecurityConfig вместе с настроенным filterChain, 
то Spring Security перехватывает запрос через свой собственный класс SecurityFilterChain.
- Посмотрим на код SecurityConfig.filterChain. 
В нем мы видим код
```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.authorizeHttpRequests(auth ->
                    auth.anyRequest().authenticated()
            )
            .formLogin(Customizer.withDefaults());
    return http.build();
}
```
В этом блоке через authorizeHttpRequests мы декларируем, что всякий запрос на backend требует авторизации (блок authorizeHttpRequests)
и для аутентификации/авторизации будет использована стандартная форма ввода логина и пароля в Spring (блок .formLogin)
Нужно заметить, что форма логина - это html, создается Spring автоматически в рантайме.
2. Затем идет проверка авторизации:
- Spring Security проверяет: "Есть ли у пользователя права?"
- Пользователь не аутентифицирован, значит доступ отклонен
3. Происходит перенаправление на форму логина:
- Spring автоматически перенаправляет на /login
- Показывает стандартную форму входа
4. Пользователь вводит данные:
5. Далее идет обработка формы логина:
- Spring Security получает данные формы
- Создает объект UsernamePasswordAuthenticationToken
- Передает его в AuthenticationManager. Этот бин мы также объявили в SecurityConfig.
и передали ему в качестве параметра наш CustomUserDetailsService, который возвращает пользователя
и passwordEncoder (бин объявленный ниже), который шифрует переданный пароль из браузера и сравнивает полученный хеш с хешем из базы данных.

6. Вернемся к нашему процессу. Далее идет аутентификация через UserDetailsService:
- AuthenticationManager вызывает наш CustomUserDetailsService
- Сервис ищет пользователя в базе данных
- Возвращает UserDetails с хешированным паролем
7. Проверка пароля:
- Spring сравнивает введенный пароль с хешем из БД
- Использует BCryptPasswordEncoder для безопасного сравнения
8. Создание сессии:
- При успешной аутентификации создается HttpSession
- Пользователь получает JSESSIONID cookie
- Spring сохраняет информацию об аутентификации в сессии
9. Перенаправление на исходный URL:
- Spring автоматически перенаправляет на исходный запрос api/me
10. Успешный доступ:
- Spring внутри проверяет сессию, что пользователь аутентифицирован
- Выполняет запрос к контроллеру
- Возвращает: "Вы вошли как: admin, роли: [ROLE_ADMIN]"

Давайте подытожим и обозначим еще раз ключевые компоненты:
SecurityFilterChain - перехватывает все запросы
AuthenticationManager - управляет процессом аутентификации
UserDetailsService - загружает данные пользователя из БД
PasswordEncoder - безопасно проверяет пароли (шифрует пароль, введенный через браузер в хеш и проверяет его с хешем из БД)
HttpSession - сохраняет состояние аутентификации

В результате пользователь получает доступ к защищенным ресурсам через безопасную аутентификацию с базой данных и мы видим в браузере его данные.

---
## 4. Итоги
В этом уроке мы рассмотрели базовые возможности Spring Security, посмотрели на его ключевые составляющие и архитектуру, 
а также на практическом примере подробно разобрали, как можно его сконфигурировать и как происходит процесс аутентификации для пользователя
в разрезе работы Spring Security.
--- 